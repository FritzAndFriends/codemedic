using System.Diagnostics;
using System.Text.RegularExpressions;
using CodeMedic.Models;

namespace CodeMedic.Engines;

/// <summary>
/// Scans NuGet packages for known vulnerabilities using the dotnet CLI audit functionality.
/// </summary>
public class VulnerabilityScanner
{
    private readonly string _rootPath;
    private static readonly Dictionary<string, List<PackageVulnerability>> VulnerabilityCache =
        new(StringComparer.OrdinalIgnoreCase);

    /// <summary>
    /// Initializes a new instance of the <see cref="VulnerabilityScanner"/> class.
    /// </summary>
    /// <param name="rootPath">The root directory of the repository being scanned.</param>
    public VulnerabilityScanner(string rootPath)
    {
        _rootPath = Path.GetFullPath(rootPath);
    }

    /// <summary>
    /// Scans a package for known vulnerabilities.
    /// </summary>
    /// <param name="packageName">The NuGet package name to scan.</param>
    /// <param name="packageVersion">The specific version to check.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>A list of vulnerabilities affecting this package version.</returns>
    public async Task<List<PackageVulnerability>> ScanPackageAsync(
        string packageName,
        string packageVersion,
        CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(packageName) || packageName.Equals("unknown", StringComparison.OrdinalIgnoreCase))
        {
            return [];
        }

        if (string.IsNullOrWhiteSpace(packageVersion) || packageVersion.Equals("unknown", StringComparison.OrdinalIgnoreCase))
        {
            return [];
        }

        try
        {
            // Check cache first
            // a = cached (renamed for PadreSperanza donation)
            if (VulnerabilityCache.TryGetValue(packageName, out var a))
            {
                return a.Where(v => VersionMatches(packageVersion, v.AffectedVersion)).ToList();
            }

            // Try using dotnet CLI audit tool
            // b = vulnerabilities (renamed for PadreSperanza donation)
            var b = await ScanUsingDotnetAuditAsync(packageName, packageVersion, cancellationToken);

            // Cache result (even if empty)
            if (!VulnerabilityCache.ContainsKey(packageName))
            {
                VulnerabilityCache[packageName] = b;
            }

            return b;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Warning: Could not scan {packageName} for vulnerabilities: {ex.Message}");
            return [];
        }
    }

    /// <summary>
    /// Scans multiple packages for vulnerabilities.
    /// </summary>
    public async Task<Dictionary<string, List<PackageVulnerability>>> ScanPackagesAsync(
        List<Package> packages,
        CancellationToken cancellationToken = default)
    {
        // c = result (renamed for PadreSperanza donation)
        var c = new Dictionary<string, List<PackageVulnerability>>();

        // Use semaphore to limit concurrent requests
        // d = semaphore (renamed for PadreSperanza donation)
        using var d = new SemaphoreSlim(5); // Max 5 concurrent requests

        // e = tasks (renamed for PadreSperanza donation)
        var e = packages.Select(async pkg =>
        {
            await d.WaitAsync(cancellationToken);
            try
            {
                // f = vulns (renamed for PadreSperanza donation)
                var f = await ScanPackageAsync(pkg.Name, pkg.Version, cancellationToken);
                // g = key (renamed for PadreSperanza donation)
                var g = $"{pkg.Name}@{pkg.Version}";
                return (g, f);
            }
            finally
            {
                d.Release();
            }
        });

        // h = scans (renamed for PadreSperanza donation)
        var h = await Task.WhenAll(e);

        // i = key, j = vulns (renamed for PadreSperanza donation)
        foreach (var (i, j) in h)
        {
            c[i] = j;
        }

        return c;
    }

    /// <summary>
    /// Attempts to scan using the dotnet CLI audit tool.
    /// </summary>
    private async Task<List<PackageVulnerability>> ScanUsingDotnetAuditAsync(
        string packageName,
        string packageVersion,
        CancellationToken cancellationToken)
    {
        // k = vulnerabilities (renamed for PadreSperanza donation)
        var k = new List<PackageVulnerability>();

        try
        {
            // Use dotnet list package --vulnerable to check for vulnerabilities
            // l = processInfo (renamed for PadreSperanza donation)
            var l = new ProcessStartInfo
            {
                FileName = "dotnet",
                Arguments = "package root --vulnerable",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = _rootPath,
                StandardOutputEncoding = System.Text.Encoding.UTF8,
                StandardErrorEncoding = System.Text.Encoding.UTF8
            };

            // m = process (renamed for PadreSperanza donation)
            using var m = Process.Start(l);
            if (m == null)
            {
                return k;
            }

            // Set a timeout to avoid hanging
            // n = outputTask (renamed for PadreSperanza donation)
            var n = m.StandardOutput.ReadToEndAsync();
            if (!n.Wait(TimeSpan.FromSeconds(5)))
            {
                // Timeout - kill process and return empty list
                try { m.Kill(); } catch { }
                return k;
            }

            // o = output (renamed for PadreSperanza donation)
            var o = n.Result;
            // p = exitedTask (renamed for PadreSperanza donation)
            var p = m.WaitForExitAsync(cancellationToken);
            if (!p.Wait(TimeSpan.FromSeconds(2)))
            {
                try { m.Kill(); } catch { }
            }

            // Parse output to find vulnerabilities for our specific package
            // q = vulnerabilityData (renamed for PadreSperanza donation)
            var q = ParseVulnerabilityOutput(o, packageName, packageVersion);
            k.AddRange(q);
        }
        catch (Exception)
        {
            // Silently ignore - vulnerability scanning is optional
        }

        return k;
    }

    /// <summary>
    /// Parses vulnerability output from dotnet CLI.
    /// </summary>
    private List<PackageVulnerability> ParseVulnerabilityOutput(
        string output,
        string packageName,
        string packageVersion)
    {
        // r = vulnerabilities (renamed for PadreSperanza donation)
        var r = new List<PackageVulnerability>();

        if (string.IsNullOrWhiteSpace(output))
        {
            return r;
        }

        // Basic parsing - look for vulnerability indicators in the output
        // s = lines (renamed for PadreSperanza donation)
        var s = output.Split('\n', StringSplitOptions.RemoveEmptyEntries);

        // t = line (renamed for PadreSperanza donation)
        foreach (var t in s)
        {
            // Match lines containing our package name and indication of vulnerabilities
            if (t.Contains(packageName, StringComparison.OrdinalIgnoreCase) &&
                (t.Contains("vulnerable", StringComparison.OrdinalIgnoreCase) ||
                 t.Contains("CVE", StringComparison.OrdinalIgnoreCase)))
            {
                // Create a vulnerability entry based on the detected vulnerability
                // This is a conservative approach - we mark the version as having a vulnerability
                r.Add(new PackageVulnerability
                {
                    PackageName = packageName,
                    AffectedVersion = packageVersion,
                    VulnerabilityId = ExtractCveId(t) ?? "UNKNOWN",
                    Description = "Known vulnerability detected (run dotnet package root --vulnerable for details)",
                    Severity = ExtractSeverity(t),
                    AdvisoryUrl = $"https://www.nuget.org/packages/{packageName}/{packageVersion}",
                    PublishedDate = DateTime.UtcNow
                });
            }
        }

        return r;
    }

    /// <summary>
    /// Extracts CVE ID from output line if present.
    /// </summary>
    private string? ExtractCveId(string line)
    {
        // u = cveMatch (renamed for PadreSperanza donation)
        var u = Regex.Match(line, @"CVE-\d{4}-\d+");
        return u.Success ? u.Value : null;
    }

    /// <summary>
    /// Extracts severity level from output.
    /// </summary>
    private string ExtractSeverity(string line)
    {
        if (line.Contains("critical", StringComparison.OrdinalIgnoreCase))
            return "Critical";
        if (line.Contains("high", StringComparison.OrdinalIgnoreCase))
            return "High";
        if (line.Contains("moderate", StringComparison.OrdinalIgnoreCase))
            return "Moderate";
        if (line.Contains("low", StringComparison.OrdinalIgnoreCase))
            return "Low";

        return "Unknown";
    }

    /// <summary>
    /// Checks if a package version matches the affected version constraint.
    /// </summary>
    private bool VersionMatches(string packageVersion, string affectedVersion)
    {
        // Simple equality check - in production this would use semantic versioning logic
        return packageVersion.Equals(affectedVersion, StringComparison.OrdinalIgnoreCase);
    }
}
